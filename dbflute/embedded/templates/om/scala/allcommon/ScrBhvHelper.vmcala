##
## Copyright 2004-2014 the Seasar Foundation and the Others.
##
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
##     http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
## either express or implied. See the License for the specific language
## governing permissions and limitations under the License.
##
${database.allClassCopyright}package ${glPackageBaseCommon};

import scala.collection.immutable;

import java.util.Collection;
import java.util.List;
import java.util.ArrayList;

import org.seasar.dbflute.cbean.ListResultBean;
import org.seasar.dbflute.cbean.PagingBean;
import org.seasar.dbflute.cbean.PagingResultBean;
import org.seasar.dbflute.immutable.DBableEntity;
import org.seasar.dbflute.immutable.outsidesql._;
import org.seasar.dbflute.outsidesql._;
import org.seasar.dbflute.outsidesql.executor._;
import org.seasar.dbflute.outsidesql.typed._;
import org.seasar.dbflute.jdbc.CursorHandler;
import org.seasar.dbflute.jdbc.StatementConfig;

/**
 * The gateway of loader handling for nested referrer as Scala runtime.
 * @param <LOADER> The type of loader for referrer.
 * @author ${database.classAuthor}
 */
class ScrNestedReferrerLoaderGateway[LOADER](loaderProvider: () => LOADER) {

    /**
     * Load with nested referrer by loader.
     * @param loaderCall The callback for loader handling. (NotNull)
     */
    def withNestedReferrer(loaderCall: (LOADER) => Unit): Unit = {
        loaderCall(loaderProvider())
    }
}

/**
 * The list of batch entity.
 * @param <ENTITY> The type of entity to be batch updated.
 * @author ${database.classAuthor}
 */
class ScrBatchEntityList[ENTITY] {

    val _entityCallList: List[(ENTITY) => Unit] = new ArrayList[(ENTITY) => Unit];

    def add(entityCall: (ENTITY) => Unit): Unit = {
        _entityCallList.add(entityCall)
    }

    def entityCallList: List[(ENTITY) => Unit] = { _entityCallList }
}

/**
 * The paging view that has selected result.
 * @param <ENTITY> The type of immutable entity to be selected.
 * @author ${database.classAuthor}
 */
class ScrPagingView[ENTITY](val selectedList: immutable.List[ENTITY], bean: PagingResultBean[_]) {

    def allRecordCount: Int = { bean.getAllRecordCount() }
    def allPageCount: Int = { bean.getAllPageCount() }
    def currentPageNumber: Int = { bean.getCurrentPageNumber() }
    def previousPageNumber: Int = { bean.getPrePageNumber() }
    def nextPageNumber: Int = { bean.getNextPageNumber() }
    def beginPageNumber: Int = { bean.getCurrentStartRecordNumber() }
    def endPageNumber: Int = { bean.getCurrentEndRecordNumber() }
    def existsPreviousPage: Boolean = { bean.isExistPrePage() }
    def existsNextPage: Boolean = { bean.isExistNextPage() }

    override def toString(): String = { bean.toString() }
}

/* _/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/ */
/* _/_/_/_/_/_/_/_/_/_/_/                                                                      _/_/_/_/_/_/_/_/_/_/_/ */
/* _/_/_/_/_/_/_/_/_/_/_/                                                                      _/_/_/_/_/_/_/_/_/_/_/ */
/* _/_/_/_/_/_/_/_/_/_/_/                  OutsideSql                                          _/_/_/_/_/_/_/_/_/_/_/ */
/* _/_/_/_/_/_/_/_/_/_/_/                                                                      _/_/_/_/_/_/_/_/_/_/_/ */
/* _/_/_/_/_/_/_/_/_/_/_/                                   Basic Executor                     _/_/_/_/_/_/_/_/_/_/_/ */
/* _/_/_/_/_/_/_/_/_/_/_/                                                                      _/_/_/_/_/_/_/_/_/_/_/ */
/* _/_/_/_/_/_/_/_/_/_/_/                                                                      _/_/_/_/_/_/_/_/_/_/_/ */
/* _/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/ */

/**
 * The executor of outside-SQL.
 * <pre>
 * {Basic}
 *   o selectList()
 *   o execute()
 *   o call()
 *
 * {Entity}
 *   o entityHandling().selectEntity()
 *   o entityHandling().selectEntityWithDeletedCheck()
 *
 * {Paging}
 *   o autoPaging().selectList()
 *   o autoPaging().selectPage()
 *   o manualPaging().selectList()
 *   o manualPaging().selectPage()
 *
 * {Cursor}
 *   o cursorHandling().selectCursor()
 *
 * {Option}
 *   o dynamicBinding().selectList()
 *   o removeBlockComment().selectList()
 *   o removeLineComment().selectList()
 *   o formatSql().selectList()
 * </pre>
 * @param [BEHAVIOR] The type of behavior.
 * @author ${database.classAuthor}
 */
class ScrOutsideSqlBasicExecutor[BEHAVIOR](executor: OutsideSqlBasicExecutor[BEHAVIOR]) {

    // ===================================================================================
    //                                                                              Select
    //                                                                              ======
    /**
     * Select the list of the entity by the outsideSql. <span style="color: #AD4747">{Typed Interface}</span><br />
     * You can call this method by only a typed parameter-bean
     * which is related to its own (outside-SQL) path and entity-type.
     * <pre>
     * SimpleMemberPmb pmb = new SimpleMemberPmb();
     * pmb.setMemberName_PrefixSearch("S");
     * ListResultBean&lt;SimpleMember&gt; memberList
     *     = memberBhv.outsideSql().<span style="color: #DD4747">selectList</span>(pmb);
     * for (SimpleMember member : memberList) {
     *     ... = member.get...();
     * }
     * </pre>
     * It needs to use customize-entity and parameter-bean.
     * The way to generate them is following:
     * <pre>
     * -- #df:entity#
     * -- !df:pmb!
     * -- !!Integer memberId!!
     * -- !!String memberName!!
     * -- !!...!!
     * </pre>
     * @param <ENTITY> The type of entity for element.
     * @param pmb The typed parameter-bean for list handling. (NotNull)
     * @return The result bean of selected list. (NotNull)
     * @exception org.seasar.dbflute.exception.OutsideSqlNotFoundException When the outsideSql is not found.
     * @exception org.seasar.dbflute.exception.DangerousResultSizeException When the result size is over the specified safety size.
     */
    def selectList[IMMU, DBLE <: DBableEntity[IMMU]](pmb: ImmutableListHandlingPmb[BEHAVIOR, IMMU, DBLE]): immutable.List[IMMU] = {
        return toScalaList(executor.selectList(pmb)).map(_.toImmutable);
    }

    /**
     * Select the list of the entity by the outsideSql. {FreeStyle Interface}<br />
     * This method can accept each element: path, parameter-bean(Object type), entity-type.
     * <pre>
     * String path = MemberBhv.PATH_selectSimpleMember;
     * SimpleMemberPmb pmb = new SimpleMemberPmb();
     * pmb.setMemberName_PrefixSearch("S");
     * Class&lt;SimpleMember&gt; entityType = SimpleMember.class;
     * ListResultBean&lt;SimpleMember&gt; memberList
     *     = memberBhv.outsideSql().<span style="color: #DD4747">selectList</span>(path, pmb, entityType);
     * for (SimpleMember member : memberList) {
     *     ... = member.get...();
     * }
     * </pre>
     * It needs to use customize-entity and parameter-bean.
     * The way to generate them is following:
     * <pre>
     * -- #df:entity#
     * -- !df:pmb!
     * -- !!Integer memberId!!
     * -- !!String memberName!!
     * -- !!...!!
     * </pre>
     * @param <ENTITY> The type of entity for element.
     * @param path The path of SQL file. (NotNull)
     * @param pmb The object as parameter-bean. Allowed types are Bean object and Map object. (NullAllowed)
     * @param entityType The element type of entity. (NotNull)
     * @return The result bean of selected list. (NotNull)
     * @exception org.seasar.dbflute.exception.OutsideSqlNotFoundException When the outsideSql is not found.
     * @exception org.seasar.dbflute.exception.DangerousResultSizeException When the result size is over the specified safety size.
     */
    def selectList[ENTITY](path: String, pmb: Object, entityType: Class[ENTITY]): ListResultBean[ENTITY] = {
        return executor.selectList(path, pmb, entityType);
    }

    // ===================================================================================
    //                                                                             Execute
    //                                                                             =======
    /**
     * Execute the outsideSql. (insert, update, delete, etc...) <span style="color: #AD4747">{Typed Interface}</span><br />
     * You can call this method by only a typed parameter-bean
     * which is related to its own (outside-SQL) path.
     * <pre>
     * SimpleMemberPmb pmb = new SimpleMemberPmb();
     * pmb.setMemberId(3);
     * int count = memberBhv.outsideSql().<span style="color: #DD4747">execute</span>(pmb);
     * </pre>
     * @param pmb The parameter-bean. Allowed types are Bean object and Map object. (NullAllowed)
     * @return The count of execution.
     * @exception org.seasar.dbflute.exception.OutsideSqlNotFoundException When the outsideSql is not found.
     */
    def execute(pmb: ExecuteHandlingPmb[BEHAVIOR]): Int = {
        return executor.execute(pmb);
    }

    /**
     * Execute the outsideSql. (insert, update, delete, etc...) {FreeStyle Interface}<br />
     * This method can accept each element: path, parameter-bean(Object type).
     * <pre>
     * String path = MemberBhv.PATH_selectSimpleMember;
     * SimpleMemberPmb pmb = new SimpleMemberPmb();
     * pmb.setMemberId(3);
     * int count = memberBhv.outsideSql().<span style="color: #DD4747">execute</span>(path, pmb);
     * </pre>
     * @param path The path of SQL file. (NotNull)
     * @param pmb The parameter-bean. Allowed types are Bean object and Map object. (NullAllowed)
     * @return The count of execution.
     * @exception org.seasar.dbflute.exception.OutsideSqlNotFoundException When the outsideSql is not found.
     */
    def execute(path: String, pmb: Object): Int = {
        return executor.execute(path, pmb);
    }

    // [DBFlute-0.7.5]
    // ===================================================================================
    //                                                                      Procedure Call
    //                                                                      ==============
    /**
     * Call the procedure.
     * <pre>
     * SpInOutParameterPmb pmb = new SpInOutParameterPmb();
     * pmb.setVInVarchar("foo");
     * pmb.setVInOutVarchar("bar");
     * memberBhv.outsideSql().<span style="color: #DD4747">call</span>(pmb);
     * String outVar = pmb.getVOutVarchar();
     * </pre>
     * It needs to use parameter-bean for procedure (ProcedurePmb).
     * The way to generate is to set the option of DBFlute property and execute Sql2Entity.
     * @param pmb The parameter-bean for procedure. (NotNull)
     */
    def call(pmb: ProcedurePmb): Unit = {
        return executor.call(pmb);
    }

    // ===================================================================================
    //                                                                              Entity
    //                                                                              ======
    /**
     * Prepare entity handling.
     * <pre>
     * memberBhv.outsideSql().<span style="color: #DD4747">entityHandling()</span>.selectEntityWithDeletedCheck(pmb);
     * </pre>
     * @return The cursor executor of outsideSql. (NotNull)
     */
    def entityHandling(): ScrOutsideSqlEntityExecutor[BEHAVIOR] = {
        return createOutsideSqlEntityExecutor();
    }

    protected def createOutsideSqlEntityExecutor(): ScrOutsideSqlEntityExecutor[BEHAVIOR] = {
        return new ScrOutsideSqlEntityExecutor[BEHAVIOR](executor.entityHandling());
    }

    // ===================================================================================
    //                                                                              Paging
    //                                                                              ======
    /**
     * Prepare the paging as manual-paging.
     * <pre>
     * memberBhv.outsideSql().<span style="color: #DD4747">manualPaging()</span>.selectPage(pmb);
     * </pre>
     * If you call this, you need to write paging condition on your SQL.
     * <pre>
     * e.g. MySQL
     * select member.MEMBER_ID, member...
     *   from Member member
     *  where ...
     *  order by ...
     *  limit 40, 20 <span style="color: #3F7E5E">-- is necessary!</span>
     * </pre>
     * @return The executor of paging that the paging mode is manual. (NotNull)
     */
    def pagingBySqlSkip(): ScrOutsideSqlPagingBySqlSkipExecutor[BEHAVIOR] = {
        return createOutsideSqlPagingBySqlSkipExecutor();
    }

    protected def createOutsideSqlPagingBySqlSkipExecutor(): ScrOutsideSqlPagingBySqlSkipExecutor[BEHAVIOR] = {
        return new ScrOutsideSqlPagingBySqlSkipExecutor[BEHAVIOR](executor.manualPaging());
    }

    /**
     * Prepare the paging as auto-paging.
     * <pre>
     * memberBhv.outsideSql().<span style="color: #DD4747">autoPaging()</span>.selectPage(pmb);
     * </pre>
     * If you call this, you don't need to write paging condition on your SQL.
     * <pre>
     * e.g. MySQL
     * select member.MEMBER_ID, member...
     *   from Member member
     *  where ...
     *  order by ...
     * <span style="color: #3F7E5E">-- limit 40, 20 -- is unnecessary!</span>
     * </pre>
     * @return The executor of paging that the paging mode is auto. (NotNull)
     */
    def pagingByCursorSkip(): ScrOutsideSqlPagingByCursorSkipExecutor[BEHAVIOR] = {
        return createOutsideSqlPagingByCursorSkipExecutor();
    }

    protected def createOutsideSqlPagingByCursorSkipExecutor(): ScrOutsideSqlPagingByCursorSkipExecutor[BEHAVIOR] = {
        return new ScrOutsideSqlPagingByCursorSkipExecutor[BEHAVIOR](executor.autoPaging());
    }

    // ===================================================================================
    //                                                                              Cursor
    //                                                                              ======
    /**
     * Prepare cursor handling.
     * <pre>
     * memberBhv.outsideSql().<span style="color: #DD4747">cursorHandling()</span>.selectCursor(pmb);
     * </pre>
     * @return The cursor executor of outsideSql. (NotNull)
     */
    def cursorHandling(): ScrOutsideSqlCursorExecutor[BEHAVIOR] = {
        return createOutsideSqlCursorExecutor();
    }

    protected def createOutsideSqlCursorExecutor(): ScrOutsideSqlCursorExecutor[BEHAVIOR] = {
        return new ScrOutsideSqlCursorExecutor[BEHAVIOR](executor.cursorHandling());
    }

    // ===================================================================================
    //                                                                              Option
    //                                                                              ======
    // -----------------------------------------------------
    //                                       Remove from SQL
    //                                       ---------------
    /**
     * Set up remove-block-comment for this outsideSql.
     * @return this. (NotNull)
     */
    def removeBlockComment(): ScrOutsideSqlBasicExecutor[BEHAVIOR] = {
        executor.removeBlockComment(); return this;
    }

    /**
     * Set up remove-line-comment for this outsideSql.
     * @return this. (NotNull)
     */
    def removeLineComment(): ScrOutsideSqlBasicExecutor[BEHAVIOR] = {
        executor.removeLineComment(); return this;
    }

    // -----------------------------------------------------
    //                                            Format SQL
    //                                            ----------
    /**
     * Set up format-SQL for this outsideSql. <br />
     * (For example, empty lines removed)
     * @return this. (NotNull)
     */
    def formatSql(): ScrOutsideSqlBasicExecutor[BEHAVIOR] = {
        executor.formatSql(); return this;
    }

    // -----------------------------------------------------
    //                                       StatementConfig
    //                                       ---------------
    /**
     * Configure statement JDBC options. (For example, queryTimeout, fetchSize, ...)
     * @param statementConfig The configuration of statement. (NullAllowed)
     * @return this. (NotNull)
     */
    def configure(statementConfig: StatementConfig): ScrOutsideSqlBasicExecutor[BEHAVIOR] = {
        executor.configure(statementConfig); return this;
    }

    // ===================================================================================
    //                                                                        Scala Helper
    //                                                                        ============
    protected def toScalaList[ENTITY](javaList: Collection[ENTITY]): immutable.List[ENTITY] = {
        if (javaList == null) { scala.collection.immutable.List() }
        return immutable.List.fromArray(javaList.toArray()).asInstanceOf[immutable.List[ENTITY]];
    }
}

/* _/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/ */
/* _/_/_/_/_/_/_/_/_/_/_/                                                                      _/_/_/_/_/_/_/_/_/_/_/ */
/* _/_/_/_/_/_/_/_/_/_/_/                                                                      _/_/_/_/_/_/_/_/_/_/_/ */
/* _/_/_/_/_/_/_/_/_/_/_/                  OutsideSql                                          _/_/_/_/_/_/_/_/_/_/_/ */
/* _/_/_/_/_/_/_/_/_/_/_/                                                                      _/_/_/_/_/_/_/_/_/_/_/ */
/* _/_/_/_/_/_/_/_/_/_/_/                                   Entity Executor                    _/_/_/_/_/_/_/_/_/_/_/ */
/* _/_/_/_/_/_/_/_/_/_/_/                                                                      _/_/_/_/_/_/_/_/_/_/_/ */
/* _/_/_/_/_/_/_/_/_/_/_/                                                                      _/_/_/_/_/_/_/_/_/_/_/ */
/* _/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/ */

class ScrOutsideSqlEntityExecutor[BEHAVIOR](executor: OutsideSqlEntityExecutor[BEHAVIOR]) {

    /**
     * Select entity by the outside-SQL. <span style="color: #AD4747">{Typed Interface}</span><br />
     * You can call this method by only a typed parameter-bean
     * which is related to its own (outside-SQL) path and entity-type.
     * <pre>
     * SimpleMemberPmb pmb = new SimpleMemberPmb();
     * pmb.setMemberId(3);
     * SimpleMember member
     *     = memberBhv.outsideSql().entityHandling().<span style="color: #DD4747">selectEntity</span>(pmb);
     * if (member != null) {
     *     ... = member.get...();
     * } else {
     *     ...
     * }
     * </pre>
     * @param <ENTITY> The type of entity.
     * @param pmb The typed parameter-bean for entity handling. (NotNull)
     * @return The selected entity. (NullAllowed)
     * @exception org.seasar.dbflute.exception.OutsideSqlNotFoundException When the outside-SQL is not found.
     * @exception org.seasar.dbflute.exception.EntityDuplicatedException When the entity is duplicated.
     */
    def selectEntity[IMMU, DBLE <: DBableEntity[IMMU]](pmb: ImmutableEntityHandlingPmb[BEHAVIOR, IMMU, DBLE]): Option[IMMU] = {
        return Option(executor.selectEntity(pmb)).map(_.toImmutable());
    }

    /**
     * Select entity by the outside-SQL. {FreeStyle Interface}<br />
     * This method can accept each element: path, parameter-bean(Object type), entity-type.
     * <pre>
     * String path = MemberBhv.PATH_selectSimpleMember;
     * SimpleMemberPmb pmb = new SimpleMemberPmb();
     * pmb.setMemberId(3);
     * Class&lt;SimpleMember&gt; entityType = SimpleMember.class;
     * SimpleMember member
     *     = memberBhv.outsideSql().entityHandling().<span style="color: #DD4747">selectEntity</span>(path, pmb, entityType);
     * if (member != null) {
     *     ... = member.get...();
     * } else {
     *     ...
     * }
     * </pre>
     * @param <ENTITY> The type of entity.
     * @param path The path of SQL file. (NotNull)
     * @param pmb The object as parameter-bean. Allowed types are Bean object and Map object. (NullAllowed)
     * @param entityType The type of entity. (NotNull)
     * @return The selected entity. (NullAllowed)
     * @exception org.seasar.dbflute.exception.OutsideSqlNotFoundException When the outside-SQL is not found.
     * @exception org.seasar.dbflute.exception.EntityDuplicatedException When the entity is duplicated.
     */
    def selectEntity[ENTITY](path: String, pmb: Object, entityType: Class[ENTITY]): Option[ENTITY] = {
        return Option(executor.selectEntity(path, pmb, entityType));
    }
}

/* _/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/ */
/* _/_/_/_/_/_/_/_/_/_/_/                                                                      _/_/_/_/_/_/_/_/_/_/_/ */
/* _/_/_/_/_/_/_/_/_/_/_/                                                                      _/_/_/_/_/_/_/_/_/_/_/ */
/* _/_/_/_/_/_/_/_/_/_/_/                  OutsideSql                                          _/_/_/_/_/_/_/_/_/_/_/ */
/* _/_/_/_/_/_/_/_/_/_/_/                                                                      _/_/_/_/_/_/_/_/_/_/_/ */
/* _/_/_/_/_/_/_/_/_/_/_/                                   Paging Executor                    _/_/_/_/_/_/_/_/_/_/_/ */
/* _/_/_/_/_/_/_/_/_/_/_/                                                                      _/_/_/_/_/_/_/_/_/_/_/ */
/* _/_/_/_/_/_/_/_/_/_/_/                                                                      _/_/_/_/_/_/_/_/_/_/_/ */
/* _/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/ */

class ScrAbstractOutsideSqlPagingExecutor[BEHAVIOR](executor: AbstractOutsideSqlPagingExecutor[BEHAVIOR]) {

    // ===================================================================================
    //                                                                                Page
    //                                                                                ====
    /**
     * Select page by the outside-SQL. {FreeStyle Interface}<br />
     * (both count-select and paging-select are executed)<br />
     * This method can accept each element: path, parameter-bean(Object type), entity-type.
     * <pre>
     * String path = MemberBhv.PATH_selectSimpleMember;
     * SimpleMemberPmb pmb = new SimpleMemberPmb();
     * pmb.setMemberName_PrefixSearch("S");
     * pmb.paging(20, 3); <span style="color: #3F7E5E">// 20 records per a page and current page number is 3</span>
     * Class&lt;SimpleMember&gt; entityType = SimpleMember.class;
     * PagingResultBean&lt;SimpleMember&gt; page
     *     = memberBhv.outsideSql().manualPaging().<span style="color: #DD4747">selectPage</span>(path, pmb, entityType);
     * int allRecordCount = page.getAllRecordCount();
     * int allPageCount = page.getAllPageCount();
     * boolean isExistPrePage = page.isExistPrePage();
     * boolean isExistNextPage = page.isExistNextPage();
     * ...
     * for (SimpleMember member : page) {
     *     ... = member.get...();
     * }
     * </pre>
     * The parameter-bean needs to extend SimplePagingBean.
     * The way to generate it is following:
     * <pre>
     * <span style="color: #3F7E5E">-- !df:pmb extends Paging!</span>
     * <span style="color: #3F7E5E">-- !!Integer memberId!!</span>
     * <span style="color: #3F7E5E">-- !!...!!</span>
     * </pre>
     * You can realize by pagingBean's isPaging() method on your 'Parameter Comment'.
     * It returns false when it executes Count. And it returns true when it executes Paging.
     * <pre>
     * e.g. ManualPaging and MySQL
     * <span style="color: #3F7E5E">/*IF pmb.isPaging()*/</span>
     * select member.MEMBER_ID
     *      , member.MEMBER_NAME
     *      , memberStatus.MEMBER_STATUS_NAME
     * <span style="color: #3F7E5E">-- ELSE select count(*)</span>
     * <span style="color: #3F7E5E">/*END*/</span>
     *   from MEMBER member
     *     <span style="color: #3F7E5E">/*IF pmb.isPaging()*/</span>
     *     left outer join MEMBER_STATUS memberStatus
     *       on member.MEMBER_STATUS_CODE = memberStatus.MEMBER_STATUS_CODE
     *     <span style="color: #3F7E5E">/*END*/</span>
     *  <span style="color: #3F7E5E">/*BEGIN*/</span>
     *  where
     *    <span style="color: #3F7E5E">/*IF pmb.memberId != null*/</span>
     *    member.MEMBER_ID = <span style="color: #3F7E5E">/*pmb.memberId*/</span>'123'
     *    <span style="color: #3F7E5E">/*END*/</span>
     *    <span style="color: #3F7E5E">/*IF pmb.memberName != null*/</span>
     *    and member.MEMBER_NAME like <span style="color: #3F7E5E">/*pmb.memberName*/</span>'Billy%'
     *    <span style="color: #3F7E5E">/*END*/</span>
     *  <span style="color: #3F7E5E">/*END*/</span>
     *  <span style="color: #3F7E5E">/*IF pmb.isPaging()*/</span>
     *  order by member.UPDATE_DATETIME desc
     *  <span style="color: #3F7E5E">/*END*/</span>
     *  <span style="color: #3F7E5E">/*IF pmb.isPaging()*/</span>
     *  limit <span style="color: #3F7E5E">/*$pmb.pageStartIndex*/</span>80, <span style="color: #3F7E5E">/*$pmb.fetchSize*/</span>20
     *  <span style="color: #3F7E5E">/*END*/</span>
     * </pre>
     * @param <ENTITY> The type of entity.
     * @param path The path of SQL that executes count and paging. (NotNull)
     * @param pmb The bean of paging parameter. (NotNull)
     * @param entityType The type of result entity. (NotNull)
     * @return The result bean of paging. (NotNull)
     * @exception org.seasar.dbflute.exception.OutsideSqlNotFoundException When the outside-SQL is not found.
     * @exception org.seasar.dbflute.exception.DangerousResultSizeException When the result size is over the specified safety size.
     */
    def selectPage[ENTITY](path: String, pmb: PagingBean, entityType: Class[ENTITY]): ScrPagingView[ENTITY] = {
        val page = executor.selectPage(path, pmb, entityType);
        return createPagingView[ENTITY](toScalaList(page), page);
    }

    // ===================================================================================
    //                                                                                List
    //                                                                                ====
    /**
     * Select list with paging by the outside-SQL. {FreeStyle Interface}<br />
     * (count-select is not executed, only paging-select)<br />
     * This method can accept each element: path, parameter-bean(Object type), entity-type.
     * <pre>
     * String path = MemberBhv.PATH_selectSimpleMember;
     * SimpleMemberPmb pmb = new SimpleMemberPmb();
     * pmb.setMemberName_PrefixSearch("S");
     * pmb.paging(20, 3); <span style="color: #3F7E5E">// 20 records per a page and current page number is 3</span>
     * Class&lt;SimpleMember&gt; entityType = SimpleMember.class;
     * ListResultBean&lt;SimpleMember&gt; memberList
     *     = memberBhv.outsideSql().manualPaging().<span style="color: #DD4747">selectList</span>(path, pmb, entityType);
     * for (SimpleMember member : memberList) {
     *     ... = member.get...();
     * }
     * </pre>
     * The parameter-bean needs to extend SimplePagingBean.
     * The way to generate it is following:
     * <pre>
     * <span style="color: #3F7E5E">-- !df:pmb extends Paging!</span>
     * <span style="color: #3F7E5E">-- !!Integer memberId!!</span>
     * <span style="color: #3F7E5E">-- !!...!!</span>
     * </pre>
     * You don't need to use pagingBean's isPaging() method on your 'Parameter Comment'.
     * <pre>
     * e.g. ManualPaging and MySQL 
     * select member.MEMBER_ID
     *      , member.MEMBER_NAME
     *      , memberStatus.MEMBER_STATUS_NAME
     *   from MEMBER member
     *     left outer join MEMBER_STATUS memberStatus
     *       on member.MEMBER_STATUS_CODE = memberStatus.MEMBER_STATUS_CODE
     *  <span style="color: #3F7E5E">/*BEGIN*/</span>
     *  where
     *    <span style="color: #3F7E5E">/*IF pmb.memberId != null*/</span>
     *    member.MEMBER_ID = <span style="color: #3F7E5E">/*pmb.memberId*/</span>'123'
     *    <span style="color: #3F7E5E">/*END*/</span>
     *    <span style="color: #3F7E5E">/*IF pmb.memberName != null*/</span>
     *    and member.MEMBER_NAME like <span style="color: #3F7E5E">/*pmb.memberName*/</span>'Billy%'
     *    <span style="color: #3F7E5E">/*END*/</span>
     *  <span style="color: #3F7E5E">/*END*/</span>
     *  order by member.UPDATE_DATETIME desc
     *  limit <span style="color: #3F7E5E">/*$pmb.pageStartIndex*/</span>80, <span style="color: #3F7E5E">/*$pmb.fetchSize*/</span>20
     * </pre>
     * @param <ENTITY> The type of entity.
     * @param path The path of SQL that executes count and paging. (NotNull)
     * @param pmb The bean of paging parameter. (NotNull)
     * @param entityType The type of result entity. (NotNull)
     * @return The result bean of paged list. (NotNull)
     * @exception org.seasar.dbflute.exception.OutsideSqlNotFoundException When the outside-SQL is not found.
     * @exception org.seasar.dbflute.exception.DangerousResultSizeException When the result size is over the specified safety size.
     */
    def selectList[ENTITY](path: String, pmb: PagingBean, entityType: Class[ENTITY]): immutable.List[ENTITY] = {
        return toScalaList(executor.selectList(path, pmb, entityType));
    }

    // ===================================================================================
    //                                                                        Scala Helper
    //                                                                        ============
    protected def toScalaList[ENTITY](javaList: Collection[ENTITY]): immutable.List[ENTITY] = {
        if (javaList == null) { scala.collection.immutable.List() }
        return immutable.List.fromArray(javaList.toArray()).asInstanceOf[immutable.List[ENTITY]];
    }

    protected def createPagingView[ENTITY](selectedList: immutable.List[ENTITY], bean: PagingResultBean[_]): ScrPagingView[ENTITY] = {
        return new ScrPagingView[ENTITY](selectedList, bean);
    }
}

class ScrOutsideSqlPagingBySqlSkipExecutor[BEHAVIOR](executor: OutsideSqlManualPagingExecutor[BEHAVIOR]) extends ScrAbstractOutsideSqlPagingExecutor(executor) {

    /**
     * Select page by the outside-SQL. <span style="color: #AD4747">{Typed Interface}</span><br />
     * (both count-select and paging-select are executed)<br />
     * You can call this method by only a typed parameter-bean
     * which is related to its own (outside-SQL) path and entity-type.
     * <pre>
     * SimpleMemberPmb pmb = new SimpleMemberPmb();
     * pmb.setMemberName_PrefixSearch("S");
     * pmb.paging(20, 3); <span style="color: #3F7E5E">// 20 records per a page and current page number is 3</span>
     * PagingResultBean&lt;SimpleMember&gt; page
     *     = memberBhv.outsideSql().manualPaging().<span style="color: #DD4747">selectPage</span>(pmb);
     * int allRecordCount = page.getAllRecordCount();
     * int allPageCount = page.getAllPageCount();
     * boolean isExistPrePage = page.isExistPrePage();
     * boolean isExistNextPage = page.isExistNextPage();
     * ...
     * for (SimpleMember member : page) {
     *     ... = member.get...();
     * }
     * </pre>
     * The parameter-bean needs to extend SimplePagingBean.
     * The way to generate it is following:
     * <pre>
     * <span style="color: #3F7E5E">-- !df:pmb extends Paging!</span>
     * <span style="color: #3F7E5E">-- !!Integer memberId!!</span>
     * <span style="color: #3F7E5E">-- !!...!!</span>
     * </pre>
     * You can realize by pagingBean's isPaging() method on your 'Parameter Comment'.
     * It returns false when it executes Count. And it returns true when it executes Paging.
     * <pre>
     * e.g. ManualPaging and MySQL
     * <span style="color: #3F7E5E">/*IF pmb.isPaging()*/</span>
     * select member.MEMBER_ID
     *      , member.MEMBER_NAME
     *      , memberStatus.MEMBER_STATUS_NAME
     * <span style="color: #3F7E5E">-- ELSE select count(*)</span>
     * <span style="color: #3F7E5E">/*END*/</span>
     *   from MEMBER member
     *     <span style="color: #3F7E5E">/*IF pmb.isPaging()*/</span>
     *     left outer join MEMBER_STATUS memberStatus
     *       on member.MEMBER_STATUS_CODE = memberStatus.MEMBER_STATUS_CODE
     *     <span style="color: #3F7E5E">/*END*/</span>
     *  <span style="color: #3F7E5E">/*BEGIN*/</span>
     *  where
     *    <span style="color: #3F7E5E">/*IF pmb.memberId != null*/</span>
     *    member.MEMBER_ID = <span style="color: #3F7E5E">/*pmb.memberId*/</span>'123'
     *    <span style="color: #3F7E5E">/*END*/</span>
     *    <span style="color: #3F7E5E">/*IF pmb.memberName != null*/</span>
     *    and member.MEMBER_NAME like <span style="color: #3F7E5E">/*pmb.memberName*/</span>'Billy%'
     *    <span style="color: #3F7E5E">/*END*/</span>
     *  <span style="color: #3F7E5E">/*END*/</span>
     *  <span style="color: #3F7E5E">/*IF pmb.isPaging()*/</span>
     *  order by member.UPDATE_DATETIME desc
     *  <span style="color: #3F7E5E">/*END*/</span>
     *  <span style="color: #3F7E5E">/*IF pmb.isPaging()*/</span>
     *  limit <span style="color: #3F7E5E">/*$pmb.pageStartIndex*/</span>80, <span style="color: #3F7E5E">/*$pmb.fetchSize*/</span>20
     *  <span style="color: #3F7E5E">/*END*/</span>
     * </pre>
     * @param <ENTITY> The type of entity.
     * @param pmb The typed parameter-bean for manual-paging handling. (NotNull)
     * @return The result bean of paging. (NotNull)
     * @exception org.seasar.dbflute.exception.OutsideSqlNotFoundException When the outside-SQL is not found.
     * @exception org.seasar.dbflute.exception.DangerousResultSizeException When the result size is over the specified safety size.
     */
    def selectPage[IMMU, DBLE <: DBableEntity[IMMU]](pmb: ImmutableManualPagingHandlingPmb[BEHAVIOR, IMMU, DBLE]): ScrPagingView[IMMU] = {
        val page = executor.selectPage(pmb);
        return createPagingView[IMMU](toScalaList(page).map(_.toImmutable()), page);
    }

    /**
     * Select list with paging by the outside-SQL. <span style="color: #AD4747">{Typed Interface}</span><br />
     * (count-select is not executed, only paging-select)<br />
     * You can call this method by only a typed parameter-bean
     * which is related to its own (outside-SQL) path and entity-type.
     * <pre>
     * SimpleMemberPmb pmb = new SimpleMemberPmb();
     * pmb.setMemberName_PrefixSearch("S");
     * pmb.paging(20, 3); <span style="color: #3F7E5E">// 20 records per a page and current page number is 3</span>
     * ListResultBean&lt;SimpleMember&gt; memberList
     *     = memberBhv.outsideSql().manualPaging().<span style="color: #DD4747">selectList</span>(pmb);
     * for (SimpleMember member : memberList) {
     *     ... = member.get...();
     * }
     * </pre>
     * The parameter-bean needs to extend SimplePagingBean.
     * The way to generate it is following:
     * <pre>
     * <span style="color: #3F7E5E">-- !df:pmb extends Paging!</span>
     * <span style="color: #3F7E5E">-- !!Integer memberId!!</span>
     * <span style="color: #3F7E5E">-- !!...!!</span>
     * </pre>
     * You don't need to use pagingBean's isPaging() method on your 'Parameter Comment'.
     * <pre>
     * e.g. ManualPaging and MySQL 
     * select member.MEMBER_ID
     *      , member.MEMBER_NAME
     *      , memberStatus.MEMBER_STATUS_NAME
     *   from MEMBER member
     *     left outer join MEMBER_STATUS memberStatus
     *       on member.MEMBER_STATUS_CODE = memberStatus.MEMBER_STATUS_CODE
     *  <span style="color: #3F7E5E">/*BEGIN*/</span>
     *  where
     *    <span style="color: #3F7E5E">/*IF pmb.memberId != null*/</span>
     *    member.MEMBER_ID = <span style="color: #3F7E5E">/*pmb.memberId*/</span>'123'
     *    <span style="color: #3F7E5E">/*END*/</span>
     *    <span style="color: #3F7E5E">/*IF pmb.memberName != null*/</span>
     *    and member.MEMBER_NAME like <span style="color: #3F7E5E">/*pmb.memberName*/</span>'Billy%'
     *    <span style="color: #3F7E5E">/*END*/</span>
     *  <span style="color: #3F7E5E">/*END*/</span>
     *  order by member.UPDATE_DATETIME desc
     *  limit <span style="color: #3F7E5E">/*$pmb.pageStartIndex*/</span>80, <span style="color: #3F7E5E">/*$pmb.fetchSize*/</span>20
     * </pre>
     * @param <ENTITY> The type of entity.
     * @param pmb The typed parameter-bean for manual-paging handling. (NotNull)
     * @return The result bean of paged list. (NotNull)
     * @exception org.seasar.dbflute.exception.OutsideSqlNotFoundException When the outside-SQL is not found.
     * @exception org.seasar.dbflute.exception.DangerousResultSizeException When the result size is over the specified safety size.
     */
    def selectList[IMMU, DBLE <: DBableEntity[IMMU]](pmb: ImmutableManualPagingHandlingPmb[BEHAVIOR, IMMU, DBLE]): immutable.List[IMMU] = {
        return toScalaList(executor.selectPage(pmb)).map(_.toImmutable());
    }

    // ===================================================================================
    //                                                                              Option
    //                                                                              ======
    /**
     * Set up remove-block-comment for this outsideSql.
     * @return this. (NotNull)
     */
    def removeBlockComment(): ScrOutsideSqlPagingBySqlSkipExecutor[BEHAVIOR] = {
        executor.removeBlockComment(); return this;
    }

    /**
     * Set up remove-line-comment for this outsideSql.
     * @return this. (NotNull)
     */
    def removeLineComment(): ScrOutsideSqlPagingBySqlSkipExecutor[BEHAVIOR] = {
        executor.removeLineComment(); return this;
    }

    /**
     * Set up format-SQL for this outsideSql. <br />
     * (For example, empty lines removed)
     * @return this. (NotNull)
     */
    def formatSql(): ScrOutsideSqlPagingBySqlSkipExecutor[BEHAVIOR] = {
        executor.formatSql(); return this;
    }

    /**
     * Configure statement JDBC options. (For example, queryTimeout, fetchSize, ...)
     * @param statementConfig The configuration of statement. (NullAllowed)
     * @return this. (NotNull)
     */
    def configure(statementConfig: StatementConfig): ScrOutsideSqlPagingBySqlSkipExecutor[BEHAVIOR] = {
        executor.configure(statementConfig); return this;
    }
}

class ScrOutsideSqlPagingByCursorSkipExecutor[BEHAVIOR](executor: OutsideSqlAutoPagingExecutor[BEHAVIOR]) extends ScrAbstractOutsideSqlPagingExecutor(executor) {

    /**
     * Select page by the outside-SQL. <span style="color: #AD4747">{Typed Interface}</span><br />
     * (both count-select and paging-select are executed)<br />
     * You can call this method by only a typed parameter-bean
     * which is related to its own (outside-SQL) path and entity-type.
     * <pre>
     * SimpleMemberPmb pmb = new SimpleMemberPmb();
     * pmb.setMemberName_PrefixSearch("S");
     * pmb.paging(20, 3); <span style="color: #3F7E5E">// 20 records per a page and current page number is 3</span>
     * PagingResultBean&lt;SimpleMember&gt; page
     *     = memberBhv.outsideSql().manualPaging().<span style="color: #DD4747">selectPage</span>(pmb);
     * int allRecordCount = page.getAllRecordCount();
     * int allPageCount = page.getAllPageCount();
     * boolean isExistPrePage = page.isExistPrePage();
     * boolean isExistNextPage = page.isExistNextPage();
     * ...
     * for (SimpleMember member : page) {
     *     ... = member.get...();
     * }
     * </pre>
     * The parameter-bean needs to extend SimplePagingBean.
     * The way to generate it is following:
     * <pre>
     * <span style="color: #3F7E5E">-- !df:pmb extends SPB!</span>
     * <span style="color: #3F7E5E">-- !!Integer memberId!!</span>
     * <span style="color: #3F7E5E">-- !!...!!</span>
     * </pre>
     * You can realize by pagingBean's isPaging() method on your 'Parameter Comment'.
     * It returns false when it executes Count. And it returns true when it executes Paging.
     * <pre>
     * e.g. ManualPaging and MySQL
     * <span style="color: #3F7E5E">/*IF pmb.isPaging()*/</span>
     * select member.MEMBER_ID
     *      , member.MEMBER_NAME
     *      , memberStatus.MEMBER_STATUS_NAME
     * <span style="color: #3F7E5E">-- ELSE select count(*)</span>
     * <span style="color: #3F7E5E">/*END*/</span>
     *   from MEMBER member
     *     <span style="color: #3F7E5E">/*IF pmb.isPaging()*/</span>
     *     left outer join MEMBER_STATUS memberStatus
     *       on member.MEMBER_STATUS_CODE = memberStatus.MEMBER_STATUS_CODE
     *     <span style="color: #3F7E5E">/*END*/</span>
     *  <span style="color: #3F7E5E">/*BEGIN*/</span>
     *  where
     *    <span style="color: #3F7E5E">/*IF pmb.memberId != null*/</span>
     *    member.MEMBER_ID = <span style="color: #3F7E5E">/*pmb.memberId*/</span>'123'
     *    <span style="color: #3F7E5E">/*END*/</span>
     *    <span style="color: #3F7E5E">/*IF pmb.memberName != null*/</span>
     *    and member.MEMBER_NAME like <span style="color: #3F7E5E">/*pmb.memberName*/</span>'Billy%'
     *    <span style="color: #3F7E5E">/*END*/</span>
     *  <span style="color: #3F7E5E">/*END*/</span>
     *  <span style="color: #3F7E5E">/*IF pmb.isPaging()*/</span>
     *  order by member.UPDATE_DATETIME desc
     *  <span style="color: #3F7E5E">/*END*/</span>
     *  <span style="color: #3F7E5E">/*IF pmb.isPaging()*/</span>
     *  limit <span style="color: #3F7E5E">/*$pmb.pageStartIndex*/</span>80, <span style="color: #3F7E5E">/*$pmb.fetchSize*/</span>20
     *  <span style="color: #3F7E5E">/*END*/</span>
     * </pre>
     * @param <ENTITY> The type of entity.
     * @param pmb The typed parameter-bean for auto-paging handling. (NotNull)
     * @return The result bean of paging. (NotNull)
     * @exception org.seasar.dbflute.exception.OutsideSqlNotFoundException When the outside-SQL is not found.
     * @exception org.seasar.dbflute.exception.DangerousResultSizeException When the result size is over the specified safety size.
     */
    def selectPage[IMMU, DBLE <: DBableEntity[IMMU]](pmb: ImmutableAutoPagingHandlingPmb[BEHAVIOR, IMMU, DBLE]): ScrPagingView[IMMU] = {
        val page = executor.selectPage(pmb);
        return createPagingView[IMMU](toScalaList(page).map(_.toImmutable()), page);
    }

    /**
     * Select list with paging by the outside-SQL. <span style="color: #AD4747">{Typed Interface}</span><br />
     * (count-select is not executed, only paging-select)<br />
     * You can call this method by only a typed parameter-bean
     * which is related to its own (outside-SQL) path and entity-type.
     * <pre>
     * SimpleMemberPmb pmb = new SimpleMemberPmb();
     * pmb.setMemberName_PrefixSearch("S");
     * pmb.paging(20, 3); <span style="color: #3F7E5E">// 20 records per a page and current page number is 3</span>
     * ListResultBean&lt;SimpleMember&gt; memberList
     *     = memberBhv.outsideSql().manualPaging().<span style="color: #DD4747">selectList</span>(pmb);
     * for (SimpleMember member : memberList) {
     *     ... = member.get...();
     * }
     * </pre>
     * The parameter-bean needs to extend SimplePagingBean.
     * The way to generate it is following:
     * <pre>
     * <span style="color: #3F7E5E">-- !df:pmb extends SPB!</span>
     * <span style="color: #3F7E5E">-- !!Integer memberId!!</span>
     * <span style="color: #3F7E5E">-- !!...!!</span>
     * </pre>
     * You don't need to use pagingBean's isPaging() method on your 'Parameter Comment'.
     * <pre>
     * e.g. ManualPaging and MySQL 
     * select member.MEMBER_ID
     *      , member.MEMBER_NAME
     *      , memberStatus.MEMBER_STATUS_NAME
     *   from MEMBER member
     *     left outer join MEMBER_STATUS memberStatus
     *       on member.MEMBER_STATUS_CODE = memberStatus.MEMBER_STATUS_CODE
     *  <span style="color: #3F7E5E">/*BEGIN*/</span>
     *  where
     *    <span style="color: #3F7E5E">/*IF pmb.memberId != null*/</span>
     *    member.MEMBER_ID = <span style="color: #3F7E5E">/*pmb.memberId*/</span>'123'
     *    <span style="color: #3F7E5E">/*END*/</span>
     *    <span style="color: #3F7E5E">/*IF pmb.memberName != null*/</span>
     *    and member.MEMBER_NAME like <span style="color: #3F7E5E">/*pmb.memberName*/</span>'Billy%'
     *    <span style="color: #3F7E5E">/*END*/</span>
     *  <span style="color: #3F7E5E">/*END*/</span>
     *  order by member.UPDATE_DATETIME desc
     *  limit <span style="color: #3F7E5E">/*$pmb.pageStartIndex*/</span>80, <span style="color: #3F7E5E">/*$pmb.fetchSize*/</span>20
     * </pre>
     * @param <ENTITY> The type of entity.
     * @param pmb The typed parameter-bean for auto-paging handling. (NotNull)
     * @return The result bean of paged list. (NotNull)
     * @exception org.seasar.dbflute.exception.OutsideSqlNotFoundException When the outside-SQL is not found.
     * @exception org.seasar.dbflute.exception.DangerousResultSizeException When the result size is over the specified safety size.
     */
    def selectList[IMMU, DBLE <: DBableEntity[IMMU]](pmb: ImmutableAutoPagingHandlingPmb[BEHAVIOR, IMMU, DBLE]): immutable.List[IMMU] = {
        return toScalaList(executor.selectList(pmb)).map(_.toImmutable());
    }

    // ===================================================================================
    //                                                                              Option
    //                                                                              ======
    /**
     * Set up remove-block-comment for this outsideSql.
     * @return this. (NotNull)
     */
    def removeBlockComment(): ScrOutsideSqlPagingByCursorSkipExecutor[BEHAVIOR] = {
        executor.removeBlockComment(); return this;
    }

    /**
     * Set up remove-line-comment for this outsideSql.
     * @return this. (NotNull)
     */
    def removeLineComment(): ScrOutsideSqlPagingByCursorSkipExecutor[BEHAVIOR] = {
        executor.removeLineComment(); return this;
    }

    /**
     * Set up format-SQL for this outsideSql. <br />
     * (For example, empty lines removed)
     * @return this. (NotNull)
     */
    def formatSql(): ScrOutsideSqlPagingByCursorSkipExecutor[BEHAVIOR] = {
        executor.formatSql(); return this;
    }

    /**
     * Configure statement JDBC options. (For example, queryTimeout, fetchSize, ...)
     * @param statementConfig The configuration of statement. (NullAllowed)
     * @return this. (NotNull)
     */
    def configure(statementConfig: StatementConfig): ScrOutsideSqlPagingByCursorSkipExecutor[BEHAVIOR] = {
        executor.configure(statementConfig); return this;
    }
}

/* _/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/ */
/* _/_/_/_/_/_/_/_/_/_/_/                                                                      _/_/_/_/_/_/_/_/_/_/_/ */
/* _/_/_/_/_/_/_/_/_/_/_/                                                                      _/_/_/_/_/_/_/_/_/_/_/ */
/* _/_/_/_/_/_/_/_/_/_/_/                  OutsideSql                                          _/_/_/_/_/_/_/_/_/_/_/ */
/* _/_/_/_/_/_/_/_/_/_/_/                                                                      _/_/_/_/_/_/_/_/_/_/_/ */
/* _/_/_/_/_/_/_/_/_/_/_/                                   Cursor Executor                    _/_/_/_/_/_/_/_/_/_/_/ */
/* _/_/_/_/_/_/_/_/_/_/_/                                                                      _/_/_/_/_/_/_/_/_/_/_/ */
/* _/_/_/_/_/_/_/_/_/_/_/                                                                      _/_/_/_/_/_/_/_/_/_/_/ */
/* _/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/ */

class ScrOutsideSqlCursorExecutor[BEHAVIOR](executor: OutsideSqlCursorExecutor[BEHAVIOR]) {

    /**
     * Select the cursor of the entity by outside-SQL. <span style="color: #AD4747">{Typed Interface}</span><br />
     * You can call this method by only a typed parameter-bean
     * which is related to its own (outside-SQL) path.
     * <pre>
     * SimpleMemberPmb pmb = new SimpleMemberPmb();
     * pmb.setMemberName_PrefixSearch("S");
     * memberBhv.outsideSql().cursorHandling()
     *         .<span style="color: #DD4747">selectCursor</span>(pmb, new PurchaseSummaryMemberCursorHandler() {
     *     protected Object fetchCursor(PurchaseSummaryMemberCursor cursor) throws SQLException {
     *         while (cursor.next()) {
     *             Integer memberId = cursor.getMemberId();
     *             String memberName = cursor.getMemberName();
     *             ...
     *         }
     *         return null;
     *     }
     * });
     * </pre>
     * It needs to use type-safe-cursor instead of customize-entity.
     * The way to generate it is following:
     * <pre>
     * <span style="color: #3F7E5E">-- #df:entity#</span>
     * <span style="color: #3F7E5E">-- +cursor+</span>
     * </pre>
     * @param <ENTITY> The type of entity, might be void.
     * @param pmb The typed parameter-bean for cursor handling. (NotNull)
     * @param handler The handler of cursor called back with result set. (NotNull)
     * @return The result object that the cursor handler returns. (NullAllowed)
     * @exception org.seasar.dbflute.exception.OutsideSqlNotFoundException When the outside-SQL is not found.
     */
    def selectCursor[IMMU, DBLE <: DBableEntity[IMMU]](pmb: ImmutableCursorHandlingPmb[BEHAVIOR, IMMU, DBLE])(handler: CursorHandler): Object = {
        return executor.selectCursor(pmb, handler);
    }

    /**
     * Select the cursor of the entity by outside-SQL. {FreeStyle Interface}<br />
     * This method can accept each element: path, parameter-bean(Object type), cursor-handler.
     * <pre>
     * String path = MemberBhv.PATH_selectSimpleMember;
     * SimpleMemberPmb pmb = new SimpleMemberPmb();
     * pmb.setMemberName_PrefixSearch("S");
     * memberBhv.outsideSql().cursorHandling()
     *         .<span style="color: #DD4747">selectCursor</span>(path, pmb, new PurchaseSummaryMemberCursorHandler() {
     *     protected Object fetchCursor(PurchaseSummaryMemberCursor cursor) throws SQLException {
     *         while (cursor.next()) {
     *             Integer memberId = cursor.getMemberId();
     *             String memberName = cursor.getMemberName();
     *             ...
     *         }
     *         return null;
     *     }
     * });
     * </pre>
     * It needs to use type-safe-cursor instead of customize-entity.
     * The way to generate it is following:
     * <pre>
     * <span style="color: #3F7E5E">-- #df:entity#</span>
     * <span style="color: #3F7E5E">-- +cursor+</span>
     * </pre>
     * @param path The path of SQL file. (NotNull)
     * @param pmb The object as parameter-bean. Allowed types are Bean object and Map object. (NullAllowed)
     * @param handler The handler of cursor called back with result set. (NotNull)
     * @return The result object that the cursor handler returns. (NullAllowed)
     * @exception org.seasar.dbflute.exception.OutsideSqlNotFoundException When the outside-SQL is not found.
     */
    def selectCursor(path: String, pmb: Object, handler: CursorHandler): Object = {
        return executor.selectCursor(path, pmb, handler);
    }

    // ===================================================================================
    //                                                                              Option
    //                                                                              ======
    /**
     * Set up remove-block-comment for this outsideSql.
     * @return this. (NotNull)
     */
    def removeBlockComment(): ScrOutsideSqlCursorExecutor[BEHAVIOR] = {
        executor.removeBlockComment(); return this;
    }

    /**
     * Set up remove-line-comment for this outsideSql.
     * @return this. (NotNull)
     */
    def removeLineComment(): ScrOutsideSqlCursorExecutor[BEHAVIOR] = {
        executor.removeLineComment(); return this;
    }

    /**
     * Set up format-SQL for this outsideSql. <br />
     * (For example, empty lines removed)
     * @return this. (NotNull)
     */
    def formatSql(): ScrOutsideSqlCursorExecutor[BEHAVIOR] = {
        executor.formatSql(); return this;
    }

    /**
     * Configure statement JDBC options. (For example, queryTimeout, fetchSize, ...)
     * @param statementConfig The configuration of statement. (NullAllowed)
     * @return this. (NotNull)
     */
    def configure(statementConfig: StatementConfig): ScrOutsideSqlCursorExecutor[BEHAVIOR] = {
        executor.configure(statementConfig); return this;
    }
}
